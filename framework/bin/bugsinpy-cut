#!env/bin/python3
import inspect
import importlib
import sys
import dis
import os
import re
import glob

if __name__ == "__main__":
    end = "# BLOCK\n"
    if (len(sys.argv) < 2):
        print("USAGE: bugsinpy-cut <test file> [<test class>] <test_method>")
        quit()
    sys.path.insert(1, os.getcwd())
    test_module = importlib.import_module(sys.argv[1])
    if (len(sys.argv) == 4):
        test_class = getattr(test_module, sys.argv[2])
        test_method = getattr(test_class, sys.argv[3])
    else:
        test_class = None
        test_method = getattr(test_module, sys.argv[2])
    code, _ = inspect.findsource(test_module)
    # Get all the imports and required functions used for this test
    calls = {}
    instrs = list(dis.get_instructions(test_method))[::-1]
    # Add function calls and imports
    for (i, instr) in enumerate(reversed(instrs)):
        if (instr.opname == 'LOAD_GLOBAL'):
            calls[instr.argval] = 'import'
        if (instr.opname == 'CALL_FUNCTION'):
            argval = instrs[len(instrs)-i+instr.arg].argval
            if (argval in calls):
                calls[argval] = 'function'
    full_code = inspect.getsource(test_module)
    # Add fixture calls if pytest
    if ("pytest" in full_code):
        for param in inspect.signature(test_method).parameters:
            calls[param] = 'function'
        m = [i[1] for i in inspect.getmembers(test_method) if i[0] == 'pytestmark']
        if (m):
            for mark in m[0]:
                if (mark.name == 'parametrize'):
                    params = mark.args[0].split(', ')
                elif (mark.name == 'usefixtures' or hasattr(mark, 'args')):
                    params = list(mark.args)
                else:
                    params = []
                for param in params:
                    if (param != ""):
                        calls[param] = 'function'
    pat = ("[ \t]*(?:from[ \t]+[A-z0-9_.]+)?[ \t]*import[ \t]+"
           "(?:[A-z0-9_., \t]+|\\[\s]+|\([A-z0-9_.,\s]+\))")
    all_imports = re.findall(pat, full_code)
    imports_to_add = {}
    funcs_to_print = []
    for (name, type_) in sorted(calls.items(), key=lambda c: c[1], reverse=True):
        if (type_ == 'function'):
            if (hasattr(test_module, name) and
                    inspect.isroutine(getattr(test_module, name))):
                used = inspect.getsource(getattr(test_module, name))
            elif (test_class and hasattr(test_class, name) and
                    inspect.isroutine(getattr(test_class, name))):
                used = inspect.getsource(getattr(test_class, name))
            else:
                used = ""
            if (used and used in full_code):
                funcs_to_print.append(used)
            else:  # change type to import if not found in code
                type_ = 'import'
        if (type_ == 'import'):
            r = re.compile(("^[\s]*(?:from ([A-z0-9_.]+))?[\s]*"
                            "import(?:.|\n)*[\s,]+(" + str(name)+")"
                            "(?:[\s,]+|$)"))
            name_imports = list(filter(r.match, all_imports))
            imports = [r.match(val).groups()
                       for val in all_imports if r.match(val)]
            for package, imp in imports:
                imports_to_add.setdefault(package, []).append(imp)
    # print each import needed
    for package, imps in imports_to_add.items():
        if (package):
            if (len(imps) < 4):
                print("from", package, "import", ",".join(imps), end="\n"+end)
            else:
                print("from", package, "import (\n", end="")
                for imp in imps:
                    print("\t".expandtabs(4)+imp+",")
                print(")\n", end=end)
        else:
            for imp in imps:
                print("import", imp, end="\n"+end)
    # print each function needed
    for func in funcs_to_print:
        print(func, end=end)
    # Get this test source
    print(inspect.getsource(test_method), end="")
    consts = list(test_method.__code__.co_consts)
    if ('__wrapped__' in test_method.__dict__):
        consts.extend(test_method.__dict__['__wrapped__'].__code__.co_consts)
    used_files = []
    for const in consts:
        if (const is not None and type(const) is str and const != ""):
            if (os.path.isfile(const)):
                used_files.append(const)
            else:
                found = False
                for const_ext in glob.glob(str(const)+".*"):
                    used_files.append(const_ext)
                    found = True
                if (not found):
                    for const_ext in glob.glob("test*/**/"+str(const)+".*", recursive=True):
                        used_files.append(const_ext)
    for f in used_files:
        file = open(f)
        lines = file.read()
        print("# FILE:", f)
        print(lines.rstrip('\n'))
