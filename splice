#!/bin/python3
import inspect
import importlib.util
import importlib
import sys
import os
import re


def linesin(source, target):
    start = -1
    while (start < len(target)):
        try:
            start = target.index(source[0], start+1)
        except ValueError:
            return None
        line = 1
        while (line < len(source) and start+line < len(target) and
                target[start+line] == source[line]):
            line += 1
        if (line == len(source)):
            return (start, start+line-1)
    return None


if __name__ == "__main__":
    if (len(sys.argv) < 2):
        print("USAGE: splice <test file> [<test class>] <test_method>")
    sys.path.insert(1, os.getcwd())
    test_file = sys.argv[1]
    test_method = sys.argv[-1]
    test_class = None
    if (len(sys.argv) == 4):
        test_class = sys.argv[2]
    full_diff = sys.stdin.read()
    cut_parts = full_diff.split('# BLOCK\n')
    try:
        test_exists = importlib.util.find_spec(test_file) is not None
    except ModuleNotFoundError:
        test_exists = False
    if (test_exists):
        test_module = importlib.import_module(test_file)
        code, m_sloc = inspect.findsource(test_module)
        test_c_module = None
        if (test_class is not None):
            if (hasattr(test_module, test_class)):
                test_c_module = getattr(test_module, test_class)
                c_sloc = inspect.findsource(test_c_module)[1]
            else:
                cut_parts.append("class "+test_class+":\n")
        splices = []
        # inject each block into the code
        for part in cut_parts:
            method_name_list = re.findall("\s*def\s+([A-z0-9_]+)\s*\(", part)
            method_name = method_name_list[0] if method_name_list else None
            splice = part.splitlines(True)
            if (method_name is None and linesin(splice, code)):
                sloc, eloc = linesin(splice, code)
            # Update the method if it exists
            elif (method_name and hasattr(test_module, method_name)):
                test_lines = inspect.getsourcelines(getattr(test_module, method_name))
                sloc, eloc = (test_lines[1]-1, test_lines[1]+len(test_lines[0])-2)
            elif (method_name and test_c_module and hasattr(test_c_module, method_name)):
                test_lines = inspect.getsourcelines(getattr(test_c_module, method_name))
                sloc, eloc = (test_lines[1]-1, test_lines[1]+len(test_lines[0])-2)
            else:
                if (test_c_module):
                    sloc = c_sloc
                else:
                    sloc = m_sloc
                # skip variable declarations & imports
                while (code[sloc].strip() != "" or "import" in code[sloc+1]):
                    sloc += 1
                # add blank line before and after
                sloc += 1
                eloc = sloc - 2
            splices.append((sloc, eloc, splice))
            # print(*code, sep="", end="")
        # Sort by start location and then LOC (to have imports first)
        splices.sort(key=lambda x: (x[0], len(x[2])), reverse=True)
        for s in splices:
            sloc, eloc, splice = s
            code = code[:sloc] + splice + code[eloc+1:]
    else:
        code = full_diff.replace("# BLOCK\n", "\n").splitlines(True)
        if (test_class is not None):
            code.insert(0, "class "+test_class+":\n")
    filename = test_file.replace('.', '/')+".py"
    os.makedirs(os.path.dirname(filename), exist_ok=True)
    test_file_out = open(filename, 'w')
    print(*code, sep="", end="", file=test_file_out)
    test_file_out.close()
