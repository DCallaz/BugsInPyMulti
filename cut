#!/bin/python3
import inspect
import importlib
import sys
import dis
import os
import re
import glob
from functools import partial as part

if __name__ == "__main__":
    end = "# BLOCK\n"
    if (len(sys.argv) < 2):
        print("USAGE: cut <test file> [<test class>] <test_method>")
        quit()
    sys.path.insert(1, os.getcwd())
    test_module = importlib.import_module(sys.argv[1])
    if (len(sys.argv) == 4):
        test_class = getattr(test_module, sys.argv[2])
        test_method = getattr(test_class, sys.argv[3])
    else:
        test_class = None
        test_method = getattr(test_module, sys.argv[2])
    code, _ = inspect.findsource(test_module)
    # Get all the imports and required functions used for this test
    calls = {}
    instrs = list(dis.get_instructions(test_method))[::-1]
    # Add function calls and imports
    for (i, instr) in enumerate(reversed(instrs)):
        if (instr.opname == 'LOAD_GLOBAL'):
            calls[instr.argval] = 'import'
        if (instr.opname == 'CALL_FUNCTION'):
            argval = instrs[len(instrs)-i+instr.arg].argval
            if (argval in calls):
                calls[argval] = 'function'
    full_code = inspect.getsource(test_module)
    # Add fixture calls if pytest
    if ("pytest" in full_code):
        for param in inspect.signature(test_method).parameters:
            calls[param] = 'function'
        m = [i[1] for i in inspect.getmembers(test_method) if i[0] == 'pytestmark']
        if (m):
            for mark in m[0]:
                if (mark.name == 'parametrize'):
                    params = mark.args[0].split(', ')
                elif (mark.name == 'usefixtures' or hasattr(mark, 'args')):
                    params = list(mark.args)
                else:
                    params = []
                for param in params:
                    if (param != ""):
                        calls[param] = 'function'
    all_import_indices = []
    for (name, type_) in sorted(calls.items(), key=lambda c: c[1], reverse=True):
        if (type_ == 'function'):
            if (hasattr(test_module, name) and
                    inspect.isroutine(getattr(test_module, name))):
                used = inspect.getsource(getattr(test_module, name))
            elif (test_class and hasattr(test_class, name) and
                    inspect.isroutine(getattr(test_class, name))):
                used = inspect.getsource(getattr(test_class, name))
            else:
                used = ""
            if (used and used in full_code):
                print(used, end=end)
            else:  # change type to import if not found in code
                type_ = 'import'
        if (type_ == 'import'):
            # TODO: multiline imports
            r = re.compile("^[\s]*(from [A-z0-9_.]+)?[\s]*import.*[\s,]+" +
                           str(name)+"([\s,]+|$)")
            name_import = list(filter(r.match, code))
            # Don't print imports that have already been printed
            name_import = [line for line in name_import if code.index(line)
                           not in all_import_indices]
            if (name_import):
                all_import_indices += name_import
                print(*name_import, end=end)
            # print("import", name)
    # Get this test source
    print(inspect.getsource(test_method), end="")
    consts = list(test_method.__code__.co_consts)
    if ('__wrapped__' in test_method.__dict__):
        consts.extend(test_method.__dict__['__wrapped__'].__code__.co_consts)
    used_files = []
    for const in consts:
        if (const is not None and type(const) is str and const != ""):
            if (os.path.isfile(const)):
                used_files.append(const)
            else:
                found = False
                for const_ext in glob.glob(str(const)+".*"):
                    used_files.append(const_ext)
                    found = True
                if (not found):
                    for const_ext in glob.glob("test*/**/"+str(const)+".*", recursive=True):
                        used_files.append(const_ext)
    for f in used_files:
        file = open(f)
        lines = file.read()
        print("# FILE:", f)
        print(lines.rstrip('\n'))
